# 1주차
- - -
## 강의 4.
* 데이터의 규모는 커질 수록 쿼리를 처리하는데 많은 시간이 소요되므로 인덱스를 잘 걸어주어야 한다.
* 데이터의 규모가 너무 거대하여 인덱스를 통해서도 비기능적 요건이 충족되지 않으면 콜드 데이터를 이관하여 분리 보관 하거나, 샤딩을 고려해봐도 좋을 것 같다.
* 크고 작은 문제들에 대한 해결법을 잘 알고 있는 것은 그만큼 많은 트러블을 접해왔다는 것이다. 문제가 발생하면 시행착오를 거치며 노련하게 경험을 쌓자.

- - -
## 강의 5.

### 대규모 데이터의 어려운 점
* 메모리 내에서 계산할 수 없기 때문에 지속적으로 디스크에서 읽어야 한다.
* 디스크는 메모리에 비해서 상당히 느리다.
* 메모리는 디스크보다 10^5 ~ 10^6 배 이상 빠르다.

### 디스크는 왜 느린가
* 메모리는 전기적인 부품이므로 물리적 구조는 탐색속도와 그다지 관계가 없다.
* 디스크는 동축 상에 원반에 쌓여있고, 데이터를 읽기 위해서는 메모리와 달리 회전 등의 물리적인 동작을 수반한다. 이러한 물리적인 구조가 탐색 속도에 영향을 준다.

### OS 레벨에서 속도 차이를 줄이는 방법
* 디스크는 속도가 느리지만 OS는 이러한 점을 커버하기 위해 연속된 데이터를 같은 위치에 쌓는다.
* 같은 위치에 쌓인 데이터들은 읽을 때 한꺼번에 읽도록 하여 1번의 디스크 회전만으로 읽는 데이터 수를 늘려서 회전 수를 최소화할 수 있다.
* 그렇다고해서 메모리와의 속도차를 극복할 수 있는 수준은 아니다.

### 전송속도, 버스의 속도차
* 데이터를 읽고나면 어딘가로 전송을 하게 되는데, 이 전송하는 구간을 버스라고 한다.
* 전송속도는 디스크에서 메모리로 보내거나 메모리에서 CPU로 보내는 등 컴퓨터 내부에서 전송하기 위한 속도이다.
* hdparm 이라는 Linux 툴을 사용하면 그 속도차를 알 수 있는데, "Timing cached reads" 는 메모리에 있는 캐시 데이터의 전송속도를 나타내고, "Timing buffered disk reads" 는 디스크의 전송속도이다.
* 메모리와 CPU는 상당히 빠른 버스로 연결되어 있고, 디스크는 상대적으로 속도가 느리다.

### 병목을 구명하기위한 작업

#### Load Average 확인
* Load Average 는 시스템 전체의 부하상황을 나타내는 지표이다. 
* top 이나 uptime 등의 명령으로 Load Average 를 확인할 수 있다.

#### CPU, I/O 중 병목 원인 조사
* Load Average 가 높은 경우, CPU 와 I/O 어느 쪽에 원인이 있는지를 조사한다.
* sar 이나 vmstat 로 시간 경과에 따라 CPU 사용률이나 I/O 대기율의 추이를 확인할 수 있으므로 이를 참고하여 규명한다.
